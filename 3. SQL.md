¿Qué es y por qué aprender SQL?
Una base de datos es una aplicación independiente que almacena una colección de datos. Así que podemos decir que se trata de una colección de información organizada por campos, registros y archivos, de manera que  se pueda seleccionar rápidamente los fragmentos de datos que se necesiten.

Una base de datos es relacional cuando esta cumple con el modelo relacional, que se refiere a la relación que existe entre las distintas entidades o tablas de la base. También conocidas como sistemas de gestión de bases de datos relacionales (RDBMS), las cuales nos permiten almacenar y gestionar gran cantidad de datos. Los datos se almacenan en diferentes tablas y las relaciones se establecen usando claves primarias u otras llaves conocidas como claves externas o foráneas.


SQL (Structured Query Language) es un lenguaje estándar e interactivo de acceso a bases de datos relacionales que permite especificar diversos tipos de operaciones en ellas, gracias a la utilización del álgebra y de cálculos relacionales, el SQL brinda la posibilidad de realizar consultas con el objetivo de recuperar información de las bases de datos de manera sencilla. Las consultas toman la forma de un lenguaje de comandos que permite seleccionar, insertar, actualizar, averiguar la ubicación de los datos, y más.

¿Por qué aprender SQL ?
SQL es un lenguaje declarativo estándar internacional de comunicación dentro de las bases de datos que nos permite a todos el acceso y manipulación de datos en una base de datos, y además se puede integrar a lenguajes de programación, por ejemplo ASP o PHP, y en combinación con cualquier base de datos específica, por ejemplo MySQL, SQL Server, MS Access, entre otras.


Desde los años 70, SQL se ha usado en cualquier base de datos relacionales en todo el mundo, su estructura y características se mantienen estables desde entonces.

El lenguaje SQL, o lenguaje de consulta estructurado, es hoy el más
utilizado en cualquier ámbito en el que se trabaje con bases de datos.
Se trata de un lenguaje que permite acceder, modificar o eliminar la
información que se almacena en las bases de datos. Esta información
está relacionada entre sí, por lo que debe ser estructurada y
almacenada siguiendo un sistema. El lenguaje SQL permite interactuar
con esa información.


Las distintas aplicaciones del lenguaje SQL

El internet ha llevado a las bases de datos a otro nivel. Son la clave del
funcionamiento de las páginas web, por lo que SQL tiene una especial
importancia en el ámbito digital. Cualquier sitio web recurre al sistema
de base de datos para que sus contenidos puedan ser utilizados. SQL
simplifica en gran medida su gestión.

Hoy, todas las empresas manejan una cantidad importante de
información, pero la clave está en saber gestionarla. En ese sentido, un
experto en SQL en el equipo de trabajo es una garantía, ya sea en el
sector de las telecomunicaciones como en la industria de la
automoción, la hostelería, la educación, la banca, el marketing... Todos
ellos son sectores muy distintos, pero con una misma necesidad: el
manejo de las bases de datos. Una base de datos correctamente
estructurada es una herramienta enormemente útil con un rendimiento
muy alto.

Entonces, ¿quién debe aprender SQL? Pues no solamente
programadores o gestores de bases de datos. Cualquier persona que
trabaje con análisis de datos o tratamiento de información debería
tener conocimientos de SQL, independientemente de que esté en el
departamento de RR.HH., Estadística o en el de Marketing. La ventaja
está en que no es difícil de aprender.

SQL permite manejar la información contenida en una base de datos,
sobre todo su utilidad radica en que facilita la búsqueda y la edición de
esos datos. Es una alternativa mucho más eficaz que la manual a la
hora de organizar información, algo que hacemos constantemente. Con
el Máster online en Marketing Intelligence de UNIR, aprenderás las
últimas tendencias de la analítica de datos aplicadas al Marketing.

## Comandos SQL .Grupos de comando.
Los comandos del SQL pueden dividirse en tres grupos:

● Comandos de definición de datos (DDL = Data Definition
Language),que permiten crear y definir nuevas bases de datos,
campos etc.

● Comandos de manipulación de datos (DML = Data
ManipulationLanguage),que permiten generar consultas para
ordenar, filtrar y extraer datos de la base de datos.

● Comandos de control y seguridad de datos, que gobiernan los
privilegios de los usuarios, los controles de acceso.
Los principales comandos del lenguaje SQL son:

![image](https://user-images.githubusercontent.com/91554777/169073550-f10d104b-63e2-4601-b235-58893d3db8c5.png)

![image](https://user-images.githubusercontent.com/91554777/169073673-c8e1449d-6504-4b94-8abb-72b343c5c20a.png)

Condiciones o criterios: por medio de ciertos modificadores, llamados
cláusulas, se consigue generar criterios con el fin de definir los datos
que se desea seleccionar o manipular.

![image](https://user-images.githubusercontent.com/91554777/169073772-41c05c80-19ad-4043-867c-e11d94087c36.png)

Operadores Lógicos

![image](https://user-images.githubusercontent.com/91554777/169073952-32a1c61c-c23c-4144-b074-259e554e57c8.png)


Operadores de Comparación

![image](https://user-images.githubusercontent.com/91554777/169074040-9e9fc907-e583-435d-95b5-9f50dfa5f3be.png)

Funciones de Agregado
Las funciones de agregado se usan dentro de una cláusula SELECT en
grupos de registros para devolver un único valor que se aplica a un
grupo de registros.

![image](https://user-images.githubusercontent.com/91554777/169074294-dcbd0fa7-631d-4067-9f3b-e0ff6cff6fdb.png)

### Definición de datos.
El conjunto de relaciones de cada base de datos debe especificarse en
el sistema en términos de un lenguaje de definición de datos (LDD). El
LDD de SQL no sólo permite la especificación de un conjunto de
relaciones, sino también de la información relativa a esas relaciones,
incluyendo:
• El esquema de cada relación.

• El dominio de valores asociado a cada atributo.

• Las restricciones de integridad.

• El conjunto de índices que se deben mantener para cada
relación.

• La información de seguridad y de autorización de cada relación.

• La estructura de almacenamiento físico de cada relación en el
disco.


![image](https://user-images.githubusercontent.com/91554777/169732872-ea714279-99ca-4407-af22-fcdf394f07bd.png)

## Tipos de datos (dominios):
• char(n).Una cadena de caracteres de longitud fija, con una longitud
especificada por el usuario.También se puede utilizar la palabra
completa character.

![image](https://user-images.githubusercontent.com/91554777/169721388-66bd4394-f414-486b-b9cf-197250cb27c3.png)

• varchar(n).Una cadena de caracteres de longitud variable con una
longitud máxima n especificada por el usuario. La forma completa,
character varying, es equivalente.

![image](https://user-images.githubusercontent.com/91554777/169721366-4c2d575a-8073-45db-ac22-311f9bca5032.png)

![image](https://user-images.githubusercontent.com/91554777/169721405-4abd3950-0915-4b89-902e-09993ab38e76.png)

• int. Un entero (un subconjunto finito de los enteros dependiente de
la máquina). La palabra completa, integer, es equivalente.

![image](https://user-images.githubusercontent.com/91554777/169721457-5a0f57e1-e3e7-4d9f-90d5-97cae5f9b696.png)

NOTA: Eiste también la posibilidad de poner atributos a la declaración de datos, ejemplo: 
El atributo UNSIGNED, nos permitirá establecer que no se podrán ingresar números negativos.

• smallint. Un entero pequeño (un subconjunto dependiente de la
máquina del tipo de dominio entero).

![image](https://user-images.githubusercontent.com/91554777/169721470-677488cf-d21e-40f0-8718-367b1d340f90.png)

• bigint. Un entero grande.

![image](https://user-images.githubusercontent.com/91554777/169721498-8b0e2c15-57b1-484b-bf79-3d5095930cbc.png)

• float(n). Un número de coma flotante cuya precisión es, al menos, de
n dígito.

![image](https://user-images.githubusercontent.com/91554777/169721504-5c60a4fe-f609-4f4b-978b-73e670479b71.png)

![image](https://user-images.githubusercontent.com/91554777/169721546-1c68f587-5943-4b6e-9240-178e2a342ede.png)


## Software de diseño de base de datos

### ¿Qué es un gestor de bases de datos?
Un sistema de gestión de bases de datos (SGBD o DBMS) es un software que proporcionan una forma de almacenar y recuperar la información de una base de datos de manera práctica y eﬁciente.

Básicamente, un SGBD ofrece una interfaz entre la base de datos y los usuarios finales o aplicaciones, asegurando que los datos estén organizados de manera consistente y que sean fácilmente accesibles.

De esta manera, los usuarios pueden crear, leer, actualizar y eliminar datos de una BD.

### MySQL Workbench
Un editor visual de base de datos MySQL que cuenta con el respaldo oficial
de MySQL. Sin duda la herramienta se caracteriza por su editor de
diagramas; desde su lienzo podrás arrastrar elementos desde el catálogo o
bien añadirlos desde la opción herramientas, disponible en el menú lateral.
Y si deseas analizar visualmente el esquema podrás exportarlo en formato
imagen o PDF o bien generar un script SQL CREATE o ALTER. MySQL
Workbench es un software libre disponible para Windows Mac OS X y Linux.
La herramienta dispone de una versión comercial la cual dispone de una
validación del modelado o la opción de ingeniaría inversa de base de datos,
características no disponibles en la versión gratuita.

### phpMyAdmin
Si quieres crear y manejar base datos de forma local (desde tu disco duro)
pero bajo un entorno web, sin duda phpMyAdmin es la herramienta que
estas buscando. Con la utilidad podrás crear, gestionar y eliminar bases de
datos, tablas y campos. También podrás ejecutar secuencias de comandos
SQL. phpMyAdmin sin duda esta orientadas a usuarios profesionales, te
recomendamos que si eres un usuario novato escojas otra herramienta.
Con la aplicación podrás importar en CSV y SQL y exportar en CSV, SQL,
XML, PDF, ISO / IEC 26300, Word y Excel entre otros. phpMyAdmin es una
herramienta de software libre disponible en español y desarrollada bajo
entorno PHP (y existente en la gran mayoría de los servidores web).

### ¿Qué es db-fiddle ?
Es una herramienta online que nos permite la simulación de una base de datos
a través de un script SQL podemos hacer desde crear una base de datos hasta
hacer consultas de tipo ddl.

Uso de la db-fiddle

Link para la herramienta online.

https://www.db-fiddle.com/

Opciones de los diferentes gestores de base de datos.

Vamos a seleccionar el gestor de base de datos MYSQL con la versión más 5.7
ya que es la versión más actualizada .

Ingresar código para creación de la base de datos.

![image](https://user-images.githubusercontent.com/91554777/169727969-1f33c948-c84e-4d67-bece-7fe7c8c63c8d.png)


Aquí es importante saber que en este apartado van todas las consultas para la
creación de la base de datos, insertar datos a las tablas, creación de tablas,
actualización de bases de datos .

![image](https://user-images.githubusercontent.com/91554777/169728017-9c33254e-af7a-421f-be06-e7eef0098078.png)

En este apartado se usan todas las sentencias como de manipulación de las
bases de datos es importante seleccionar la base de datos para poder hacer
uso de ella y poder hacer las operaciones que se quieran.

![image](https://user-images.githubusercontent.com/91554777/169728050-83e16185-2dff-4ba5-a061-fec9345756f9.png)


## DDL

EJEMPLO:
Tomando encuenta el primer ejemplo, tenemos el siguiente diagrama entidad relación

![image](https://user-images.githubusercontent.com/91554777/169723906-e29f9db8-f37a-426e-9c20-dd410f22b786.png)

![image](https://user-images.githubusercontent.com/91554777/169734782-1dd84674-6c2c-46ce-a8d5-3892927fa090.png)

![image](https://user-images.githubusercontent.com/91554777/169734939-394b46b3-2539-443d-ae85-24d78d1d9e03.png)

![image](https://user-images.githubusercontent.com/91554777/169735089-fa86ca41-7311-40f6-90cc-a293e6834b71.png)

![image](https://user-images.githubusercontent.com/91554777/169735254-40f29e3d-4a88-4df7-9674-b7e60dc6a432.png)

![image](https://user-images.githubusercontent.com/91554777/169735328-08db72c1-ffd7-4104-bd28-26daa0ad34b0.png)

![image](https://user-images.githubusercontent.com/91554777/169735346-3c658aac-81a0-473a-80b8-325c07a25f7f.png)







Utilizando la herramienta de https://www.db-fiddle.com/ iniciamos a escribir el código

     CREATE DATABASE biblioteca;
     USE biblioteca;
    
Con estos comandos hemos creado la BD y estamos entrando en ella, para crear sus tablas comenzamos con las que no tengan dependencia, es decir  ninguna clave foranea.

    CREATE TABLE autores (
    id_autor VARCHAR(100) PRIMARY KEY,
    nombre_autor VARCHAR(100) NOT NULL
    );
    
Hacemos esto con todas las tablas establecidas en el modelo

      CREATE TABLE libros (
      isbn INT UNSIGNED PRIMARY KEY,
      editorial VARCHAR(100) NOT NULL,
      año_escritura DATE,
      titulo VARCHAR(100) NOT NULL
      );
      CREATE TABLE personas (
      dni VARCHAR(10) PRIMARY KEY,
      nombre VARCHAR(50) NOT NULL,
      apellidos VARCHAR(50),
      direccion VARCHAR(100),
      telefono INT UNSIGNED
      );
      CREATE TABLE prestamos (
      id_prestamo INT UNSIGNED PRIMARY KEY,
      fecha_real DATE NOT NULL,
      fecha_prestamo DATE NOT NULL,
      dni1 VARCHAR(10),
      FOREIGN KEY (dni1) REFERENCES personas(dni)
      );
      CREATE TABLE volumenes (
      id_volumen INT UNSIGNED PRIMARY KEY,
      deteriodo VARCHAR(2) NOT NULL,
      id_prestamo1 INT UNSIGNED NOT NULL,
      isbn2  INT UNSIGNED NOT NULL,
      FOREIGN KEY (isbn2) REFERENCES libros(isbn),
      FOREIGN KEY (id_prestamo1) REFERENCES prestamos(id_prestamo)
      );
      CREATE TABLE auto_lib (
      id_autor1  VARCHAR(100) NOT NULL,
      isbn1 INT UNSIGNED NOT NULL,
      FOREIGN KEY (isbn1) REFERENCES libros(isbn),
      FOREIGN KEY (id_autor1) REFERENCES autores(id_autor)
      );
      
    
https://www.db-fiddle.com/f/f5YQQo1MCXhD95LFCdiYFB/0



## Insertar y visualizar datos
Las bases de datos relacionales están formadas por un conjunto de
relaciones, a cada una de las cuales se le asigna un nombre único. Cada
relación posee una estructura similar. SQL permite el uso de valores nulos
para indicar que el valor es desconocido o no existe. También permite al
usuario especificar los atributos que no pueden contener valores nulos. (NOT NULL)
La estructura básica de una expresión SQL consta de tres cláusulas: select,
from y where.

• La cláusula select se corresponde con la operación proyección del
álgebra relacional. Se usa para obtener una relación de los atributos
deseados en el resultado de una consulta.

• La cláusula from se corresponde con la operación producto
cartesiano del álgebra relacional. Genera una lista de las relaciones
que deben ser analizadas en la evaluación de la expresión.

• La cláusula where se corresponde con el predicado selección del
álgebra relacional.Es un predicado que engloba a los atributos de las
relaciones que aparecen en la cláusula from.

Que el término select tenga un significado diferente en SQL que en el
álgebra relacional es un hecho histórico desafortunado. En este capítulo se
destacan las diferentes interpretaciones para reducir al mínimo las posibles
confusiones.


![image](https://user-images.githubusercontent.com/91554777/170126004-d47901e3-6fdc-41ad-9961-d019b16336a5.png)

![image](https://user-images.githubusercontent.com/91554777/170126201-4a1c38da-94d7-4d0c-a28a-f5aa14b9a32f.png)

Tomando el ejemplo en el que estamos trabajando vamos a ingresar los datos a la base, tanto las fechas como el texto lo ingresamos con comillas simples, ademas de DATE para las fechas si queremos solo el año lo declaramos como YEAR.

     CREATE DATABASE biblioteca;
      USE biblioteca;
     CREATE TABLE autores (
     id_autor VARCHAR(100) PRIMARY KEY,
     nombre_autor VARCHAR(100) NOT NULL
     );
     --Insertamos los datos
     INSERT INTO autores VALUES ('aut1','Jan Márquez');
     INSERT INTO autores VALUES ('aut2','Miguel Pérez');
     INSERT INTO autores VALUES ('aut3','Angel Santos');
     INSERT INTO autores VALUES ('aut4','Pedro Sánchez');
     INSERT INTO autores VALUES ('aut5','Daniel Nieves');
     INSERT INTO autores VALUES ('aut6','Adrian Luevano');
     INSERT INTO autores VALUES ('aut7','Ivan Juárez');
     INSERT INTO autores VALUES ('aut8','Wendy Beltran');
     INSERT INTO autores VALUES ('aut9','María Urbina');

     CREATE TABLE libros (
     isbn INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
     editorial VARCHAR(100) NOT NULL,
     año_escritura YEAR, 
     titulo VARCHAR(100) NOT NULL
     );
     INSERT INTO libros VALUES (01,'Editorial Planeta','1998','Pan y vino');
     INSERT INTO libros VALUES (02,'Editorial Editores Mexicanos','1998','Renacer');
     INSERT INTO libros VALUES (03,'Editorial Planeta','1980','Historia del mundo');
     INSERT INTO libros VALUES (04,'Editorial Editanet','1990','Regreso a la Ciudad');
     INSERT INTO libros VALUES (05,'Editorial Editanet','2005','Matemática para niños');
     INSERT INTO libros VALUES (06,'Editorial Editanet','2009','Caso de nuevo');
     INSERT INTO libros VALUES (07,'Editorial Planeta','1974','Manejando las emociones');
     INSERT INTO libros VALUES (08,'Editorial Edimex','1996','Como hacer BD');
     INSERT INTO libros VALUES (09,'Editorial Planeta','1985','Descifrando el futuro');
     INSERT INTO libros VALUES (10,'Editorial Edimex','2010','Angel');

     CREATE TABLE personas (
     dni VARCHAR(10) PRIMARY KEY,
     nombre VARCHAR(50) NOT NULL,
     apellidos VARCHAR(50),
     direccion VARCHAR(100),
     telefono BIGINT UNSIGNED
     );
     INSERT INTO personas VALUES (74659,'Juan Pedro','Martínez Pérez','Av del trabajo #15 colonia petrolera',5567465353);
     INSERT INTO personas VALUES (76589,'Daniel',NULL,NULL,56789835);
     INSERT INTO personas VALUES (878945,'Angélica','Juárez','Priv del desierto #34',554598093);
     INSERT INTO personas VALUES (90867,'Adrián','López Pérez','Aquiles Serdán #34',5567873423);
     INSERT INTO personas VALUES (65478,'Monserrat','Martínez Annaya','Potrero #34 colonia Américas',56784534);
     INSERT INTO personas VALUES (34678,'Ángeles','Sánchez Leal','Av del Rosario #45 colonia Rosario',5576897876);
     INSERT INTO personas VALUES (56749,'Juana','Domíngez Campos','Andador peten #45 colonia Roma',5678563465);
     INSERT INTO personas VALUES (28490,'Andrea','Manrriquez Angulo','Av San pedro #90 colina San Pedro',5598478349);
     INSERT INTO personas VALUES (47893,'Paulo','Dávila Arcos','Patriotismo #12 colonia Puerto Áereo',5545768934);
     INSERT INTO personas VALUES (19840,'Armando','Martínez Hernández','Desccartes #2 colonia Centro',5545123421);

     CREATE TABLE prestamos (
     id_prestamo INT UNSIGNED PRIMARY KEY,
     fecha_real DATE NOT NULL,
     fecha_prestamo DATE NOT NULL,
     dni1 VARCHAR(10),
     FOREIGN KEY (dni1) REFERENCES personas(dni)
     );
     INSERT INTO prestamos VALUES (19,'2022-05-01','2022-03-01',74659);
     INSERT INTO prestamos VALUES (31,'2022-03-12','2022-02-14',74659);
     INSERT INTO prestamos VALUES (45,'2022-05-10','2021-04-13',47893);
     INSERT INTO prestamos VALUES (34,'2022-05-01','2022-05-09',28490);
     INSERT INTO prestamos VALUES (23,'2022-04-15','2022-04-24',19840);

     CREATE TABLE volumenes (
     id_volumen INT UNSIGNED PRIMARY KEY,
     deteriodo VARCHAR(2) NOT NULL,
     id_prestamo1 INT UNSIGNED NOT NULL,
     isbn2  INT UNSIGNED NOT NULL,
     FOREIGN KEY (isbn2) REFERENCES libros(isbn),
     FOREIGN KEY (id_prestamo1) REFERENCES prestamos(id_prestamo)
     );
     INSERT INTO volumenes VALUES (09989,'no',19,01);
     INSERT INTO volumenes VALUES (09990,'si',31,06);
     INSERT INTO volumenes VALUES (09991,'no',45,03);
     INSERT INTO volumenes VALUES (09992,'si',23,04);
     INSERT INTO volumenes VALUES (09993,'no',34,05);

     CREATE TABLE auto_lib (
     id_autor1  VARCHAR(100) NOT NULL,
     isbn1 INT UNSIGNED NOT NULL,
     FOREIGN KEY (id_autor1) REFERENCES autores(id_autor),
     FOREIGN KEY (isbn1) REFERENCES libros(isbn)
     );
     INSERT INTO auto_lib VALUES ('aut2',05);
     INSERT INTO auto_lib VALUES ('aut5',03);
     INSERT INTO auto_lib VALUES ('aut3',01);
     INSERT INTO auto_lib VALUES ('aut1',02);
     INSERT INTO auto_lib VALUES ('aut4',03);


* UNIQUE

Nos permite establecer este atributo a los campos que requerimos tengan datos que no se puedan repetir.

* DELETE

Borra una serie de filas de la tabla. Podemos usar una claúsula WHERE para limitar las filas a borrar, a las que cumplan una condición. La sintaxis sería:

DELETE FROM nombre_tabla WHERE condicion


DELETE FROM libros WHERE id = 2;

O borrar todos los datos de la tabla

DELETE FROM libros;

* TRUNCATE

A diferencia de DELETE, TRUNCATE elimina todas las filas de la tabla sin borrar la tabla. También resetea los contadores de auto incremento a 0. No borra la tabla como tal, la llamada estructura, por lo que luego puede comenzar a hacer inserciones. La sintaxis es:

TRUNCATE TABLE nombre_tabla;

TRUNCATE TABLE libros;

Diferencia entre truncate y delete

![image](https://user-images.githubusercontent.com/91554777/170414244-779243c3-c574-4b58-ad38-befb2e04a334.png)


* DROP

Finalmente llegamos a DROP. A diferencia de la anterior, DROP no sólo elimina los datos, sino que también eliminar la estructura de la tabla.

DROP TABLE nombre_tabla;

DROP TABLE libros;

* DROP DATABASE

Es idéntica a la anterior pero en lugar de borrar una tabla, borra una base de datos al completo. Podemos incluir en la sentencia IF EXISTS de forma que evitemos el error en caso de que no exista la base de datos (muy útil a la hora de hacer copias de seguridad de las bases de datos).

DROP DATABASE [IF EXISTS] nombre_base_datos;

DROP DATABASE biblioteca;

* AUTO INCREMENT  
permite generar un número único cuando insertamos un nuevo registro en la tabla.

Se utiliza para tener una clave primaria de una tabla mediante la generación automática de un número secuencial único en la tabla.

Una clave principal debe ser única ya que identifica de manera única una fila en una base de datos. Pero, ¿cómo podemos asegurarnos de que la clave principal siempre sea única? Una de las soluciones posibles sería utilizar una fórmula para generar la clave principal, que verifica la existencia de la clave en la tabla, antes de agregar datos. Esto puede funcionar bien, pero como puede ver, el enfoque es complejo y no infalible. Para evitar dicha complejidad y garantizar que la clave principal sea siempre única, podemos usar la función Incremento automático de MySQL para generar claves primarias. El incremento automático se usa con el tipo de datos INT. 
