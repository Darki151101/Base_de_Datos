¿Qué es y por qué aprender SQL?
Una base de datos es una aplicación independiente que almacena una colección de datos. Así que podemos decir que se trata de una colección de información organizada por campos, registros y archivos, de manera que  se pueda seleccionar rápidamente los fragmentos de datos que se necesiten.

Una base de datos es relacional cuando esta cumple con el modelo relacional, que se refiere a la relación que existe entre las distintas entidades o tablas de la base. También conocidas como sistemas de gestión de bases de datos relacionales (RDBMS), las cuales nos permiten almacenar y gestionar gran cantidad de datos. Los datos se almacenan en diferentes tablas y las relaciones se establecen usando claves primarias u otras llaves conocidas como claves externas o foráneas.


SQL (Structured Query Language) es un lenguaje estándar e interactivo de acceso a bases de datos relacionales que permite especificar diversos tipos de operaciones en ellas, gracias a la utilización del álgebra y de cálculos relacionales, el SQL brinda la posibilidad de realizar consultas con el objetivo de recuperar información de las bases de datos de manera sencilla. Las consultas toman la forma de un lenguaje de comandos que permite seleccionar, insertar, actualizar, averiguar la ubicación de los datos, y más.

¿Por qué aprender SQL ?
SQL es un lenguaje declarativo estándar internacional de comunicación dentro de las bases de datos que nos permite a todos el acceso y manipulación de datos en una base de datos, y además se puede integrar a lenguajes de programación, por ejemplo ASP o PHP, y en combinación con cualquier base de datos específica, por ejemplo MySQL, SQL Server, MS Access, entre otras.


Desde los años 70, SQL se ha usado en cualquier base de datos relacionales en todo el mundo, su estructura y características se mantienen estables desde entonces.

El lenguaje SQL, o lenguaje de consulta estructurado, es hoy el más
utilizado en cualquier ámbito en el que se trabaje con bases de datos.
Se trata de un lenguaje que permite acceder, modificar o eliminar la
información que se almacena en las bases de datos. Esta información
está relacionada entre sí, por lo que debe ser estructurada y
almacenada siguiendo un sistema. El lenguaje SQL permite interactuar
con esa información.


Las distintas aplicaciones del lenguaje SQL

El internet ha llevado a las bases de datos a otro nivel. Son la clave del
funcionamiento de las páginas web, por lo que SQL tiene una especial
importancia en el ámbito digital. Cualquier sitio web recurre al sistema
de base de datos para que sus contenidos puedan ser utilizados. SQL
simplifica en gran medida su gestión.

Hoy, todas las empresas manejan una cantidad importante de
información, pero la clave está en saber gestionarla. En ese sentido, un
experto en SQL en el equipo de trabajo es una garantía, ya sea en el
sector de las telecomunicaciones como en la industria de la
automoción, la hostelería, la educación, la banca, el marketing... Todos
ellos son sectores muy distintos, pero con una misma necesidad: el
manejo de las bases de datos. Una base de datos correctamente
estructurada es una herramienta enormemente útil con un rendimiento
muy alto.

Entonces, ¿quién debe aprender SQL? Pues no solamente
programadores o gestores de bases de datos. Cualquier persona que
trabaje con análisis de datos o tratamiento de información debería
tener conocimientos de SQL, independientemente de que esté en el
departamento de RR.HH., Estadística o en el de Marketing. La ventaja
está en que no es difícil de aprender.

SQL permite manejar la información contenida en una base de datos,
sobre todo su utilidad radica en que facilita la búsqueda y la edición de
esos datos. Es una alternativa mucho más eficaz que la manual a la
hora de organizar información, algo que hacemos constantemente. Con
el Máster online en Marketing Intelligence de UNIR, aprenderás las
últimas tendencias de la analítica de datos aplicadas al Marketing.

## Comandos SQL .Grupos de comando.
Los comandos del SQL pueden dividirse en tres grupos:

● Comandos de definición de datos (DDL = Data Definition
Language),que permiten crear y definir nuevas bases de datos,
campos etc.

● Comandos de manipulación de datos (DML = Data
ManipulationLanguage),que permiten generar consultas para
ordenar, filtrar y extraer datos de la base de datos.

● Comandos de control y seguridad de datos, que gobiernan los
privilegios de los usuarios, los controles de acceso.
Los principales comandos del lenguaje SQL son:

![image](https://user-images.githubusercontent.com/91554777/169073550-f10d104b-63e2-4601-b235-58893d3db8c5.png)

![image](https://user-images.githubusercontent.com/91554777/169073673-c8e1449d-6504-4b94-8abb-72b343c5c20a.png)

Condiciones o criterios: por medio de ciertos modificadores, llamados
cláusulas, se consigue generar criterios con el fin de definir los datos
que se desea seleccionar o manipular.

![image](https://user-images.githubusercontent.com/91554777/169073772-41c05c80-19ad-4043-867c-e11d94087c36.png)

Operadores Lógicos

![image](https://user-images.githubusercontent.com/91554777/169073952-32a1c61c-c23c-4144-b074-259e554e57c8.png)


Operadores de Comparación

![image](https://user-images.githubusercontent.com/91554777/169074040-9e9fc907-e583-435d-95b5-9f50dfa5f3be.png)

Funciones de Agregado
Las funciones de agregado se usan dentro de una cláusula SELECT en
grupos de registros para devolver un único valor que se aplica a un
grupo de registros.

![image](https://user-images.githubusercontent.com/91554777/169074294-dcbd0fa7-631d-4067-9f3b-e0ff6cff6fdb.png)

### Definición de datos.
El conjunto de relaciones de cada base de datos debe especificarse en
el sistema en términos de un lenguaje de definición de datos (LDD). El
LDD de SQL no sólo permite la especificación de un conjunto de
relaciones, sino también de la información relativa a esas relaciones,
incluyendo:
• El esquema de cada relación.

• El dominio de valores asociado a cada atributo.

• Las restricciones de integridad.

• El conjunto de índices que se deben mantener para cada
relación.

• La información de seguridad y de autorización de cada relación.

• La estructura de almacenamiento físico de cada relación en el
disco.


![image](https://user-images.githubusercontent.com/91554777/169732872-ea714279-99ca-4407-af22-fcdf394f07bd.png)

## Tipos de datos (dominios):
• char(n).Una cadena de caracteres de longitud fija, con una longitud
especificada por el usuario.También se puede utilizar la palabra
completa character.

![image](https://user-images.githubusercontent.com/91554777/169721388-66bd4394-f414-486b-b9cf-197250cb27c3.png)

• varchar(n).Una cadena de caracteres de longitud variable con una
longitud máxima n especificada por el usuario. La forma completa,
character varying, es equivalente.

![image](https://user-images.githubusercontent.com/91554777/169721366-4c2d575a-8073-45db-ac22-311f9bca5032.png)

![image](https://user-images.githubusercontent.com/91554777/169721405-4abd3950-0915-4b89-902e-09993ab38e76.png)

• int. Un entero (un subconjunto finito de los enteros dependiente de
la máquina). La palabra completa, integer, es equivalente.

![image](https://user-images.githubusercontent.com/91554777/169721457-5a0f57e1-e3e7-4d9f-90d5-97cae5f9b696.png)

NOTA: Eiste también la posibilidad de poner atributos a la declaración de datos, ejemplo: 
El atributo UNSIGNED, nos permitirá establecer que no se podrán ingresar números negativos.

• smallint. Un entero pequeño (un subconjunto dependiente de la
máquina del tipo de dominio entero).

![image](https://user-images.githubusercontent.com/91554777/169721470-677488cf-d21e-40f0-8718-367b1d340f90.png)

• bigint. Un entero grande.

![image](https://user-images.githubusercontent.com/91554777/169721498-8b0e2c15-57b1-484b-bf79-3d5095930cbc.png)

• float(n). Un número de coma flotante cuya precisión es, al menos, de
n dígito.

![image](https://user-images.githubusercontent.com/91554777/169721504-5c60a4fe-f609-4f4b-978b-73e670479b71.png)

![image](https://user-images.githubusercontent.com/91554777/169721546-1c68f587-5943-4b6e-9240-178e2a342ede.png)


## Software de diseño de base de datos

### ¿Qué es un gestor de bases de datos?
Un sistema de gestión de bases de datos (SGBD o DBMS) es un software que proporcionan una forma de almacenar y recuperar la información de una base de datos de manera práctica y eﬁciente.

Básicamente, un SGBD ofrece una interfaz entre la base de datos y los usuarios finales o aplicaciones, asegurando que los datos estén organizados de manera consistente y que sean fácilmente accesibles.

De esta manera, los usuarios pueden crear, leer, actualizar y eliminar datos de una BD.

### MySQL Workbench
Un editor visual de base de datos MySQL que cuenta con el respaldo oficial
de MySQL. Sin duda la herramienta se caracteriza por su editor de
diagramas; desde su lienzo podrás arrastrar elementos desde el catálogo o
bien añadirlos desde la opción herramientas, disponible en el menú lateral.
Y si deseas analizar visualmente el esquema podrás exportarlo en formato
imagen o PDF o bien generar un script SQL CREATE o ALTER. MySQL
Workbench es un software libre disponible para Windows Mac OS X y Linux.
La herramienta dispone de una versión comercial la cual dispone de una
validación del modelado o la opción de ingeniaría inversa de base de datos,
características no disponibles en la versión gratuita.

### phpMyAdmin
Si quieres crear y manejar base datos de forma local (desde tu disco duro)
pero bajo un entorno web, sin duda phpMyAdmin es la herramienta que
estas buscando. Con la utilidad podrás crear, gestionar y eliminar bases de
datos, tablas y campos. También podrás ejecutar secuencias de comandos
SQL. phpMyAdmin sin duda esta orientadas a usuarios profesionales, te
recomendamos que si eres un usuario novato escojas otra herramienta.
Con la aplicación podrás importar en CSV y SQL y exportar en CSV, SQL,
XML, PDF, ISO / IEC 26300, Word y Excel entre otros. phpMyAdmin es una
herramienta de software libre disponible en español y desarrollada bajo
entorno PHP (y existente en la gran mayoría de los servidores web).

### ¿Qué es db-fiddle ?
Es una herramienta online que nos permite la simulación de una base de datos
a través de un script SQL podemos hacer desde crear una base de datos hasta
hacer consultas de tipo ddl.

Uso de la db-fiddle

Link para la herramienta online.

https://www.db-fiddle.com/

Opciones de los diferentes gestores de base de datos.

Vamos a seleccionar el gestor de base de datos MYSQL con la versión más 5.7
ya que es la versión más actualizada .

Ingresar código para creación de la base de datos.

![image](https://user-images.githubusercontent.com/91554777/169727969-1f33c948-c84e-4d67-bece-7fe7c8c63c8d.png)


Aquí es importante saber que en este apartado van todas las consultas para la
creación de la base de datos, insertar datos a las tablas, creación de tablas,
actualización de bases de datos .

![image](https://user-images.githubusercontent.com/91554777/169728017-9c33254e-af7a-421f-be06-e7eef0098078.png)

En este apartado se usan todas las sentencias como de manipulación de las
bases de datos es importante seleccionar la base de datos para poder hacer
uso de ella y poder hacer las operaciones que se quieran.

![image](https://user-images.githubusercontent.com/91554777/169728050-83e16185-2dff-4ba5-a061-fec9345756f9.png)


## DDL

EJEMPLO:
Tomando encuenta el primer ejemplo, tenemos el siguiente diagrama entidad relación

![image](https://user-images.githubusercontent.com/91554777/170833311-3ffe2c46-1571-4461-862a-28c66eb42bb8.png)

![image](https://user-images.githubusercontent.com/91554777/170833341-9a5eaa02-3dcf-4097-9c7c-e95dab6652c7.png)

![image](https://user-images.githubusercontent.com/91554777/170833360-35d4f185-73ed-4f2f-b0e0-9db0fdacd37f.png)

![image](https://user-images.githubusercontent.com/91554777/170833413-921db57f-72c9-4a2b-ba0b-83f0e22aae91.png)

![image](https://user-images.githubusercontent.com/91554777/170833466-161932a1-10c8-4681-bb7c-b383766cc79f.png)

![image](https://user-images.githubusercontent.com/91554777/170833477-257dfcda-71bf-4912-a790-cf7d34fde1e5.png)


Utilizando la herramienta de https://www.db-fiddle.com/ iniciamos a escribir el código

     CREATE DATABASE biblioteca;
     USE biblioteca;
    
Con estos comandos hemos creado la BD y estamos entrando en ella, para crear sus tablas comenzamos con las que no tengan dependencia, es decir  ninguna clave foranea.

    CREATE TABLE autores (
    id_autor VARCHAR(100) PRIMARY KEY,
    nombre_autor VARCHAR(100) NOT NULL
    );
    
Hacemos esto con todas las tablas establecidas en el modelo

      CREATE TABLE libros (
      isbn INT UNSIGNED PRIMARY KEY,
      editorial VARCHAR(100) NOT NULL,
      año_escritura DATE,
      titulo VARCHAR(100) NOT NULL
      );
      CREATE TABLE personas (
      dni VARCHAR(10) PRIMARY KEY,
      nombre VARCHAR(50) NOT NULL,
      apellidos VARCHAR(50),
      direccion VARCHAR(100),
      telefono INT UNSIGNED
      );
      CREATE TABLE prestamos (
      id_prestamo INT UNSIGNED PRIMARY KEY,
      fecha_real DATE NOT NULL,
      fecha_prestamo DATE NOT NULL,
      dni1 VARCHAR(10),
      FOREIGN KEY (dni1) REFERENCES personas(dni)
      );
      CREATE TABLE volumenes (
      id_volumen INT UNSIGNED PRIMARY KEY,
      deteriodo VARCHAR(2) NOT NULL,
      id_prestamo1 INT UNSIGNED NOT NULL,
      isbn2  INT UNSIGNED NOT NULL,
      FOREIGN KEY (isbn2) REFERENCES libros(isbn),
      FOREIGN KEY (id_prestamo1) REFERENCES prestamos(id_prestamo)
      );
      CREATE TABLE auto_lib (
      id_autor1  VARCHAR(100) NOT NULL,
      isbn1 INT UNSIGNED NOT NULL,
      FOREIGN KEY (isbn1) REFERENCES libros(isbn),
      FOREIGN KEY (id_autor1) REFERENCES autores(id_autor)
      );
      
    
https://www.db-fiddle.com/f/f5YQQo1MCXhD95LFCdiYFB/0



## Insertar y visualizar datos
Las bases de datos relacionales están formadas por un conjunto de
relaciones, a cada una de las cuales se le asigna un nombre único. Cada
relación posee una estructura similar. SQL permite el uso de valores nulos
para indicar que el valor es desconocido o no existe. También permite al
usuario especificar los atributos que no pueden contener valores nulos. (NOT NULL)
La estructura básica de una expresión SQL consta de tres cláusulas: select,
from y where.

• La cláusula select se corresponde con la operación proyección del
álgebra relacional. Se usa para obtener una relación de los atributos
deseados en el resultado de una consulta.

• La cláusula from se corresponde con la operación producto
cartesiano del álgebra relacional. Genera una lista de las relaciones
que deben ser analizadas en la evaluación de la expresión.

• La cláusula where se corresponde con el predicado selección del
álgebra relacional.Es un predicado que engloba a los atributos de las
relaciones que aparecen en la cláusula from.

Que el término select tenga un significado diferente en SQL que en el
álgebra relacional es un hecho histórico desafortunado. En este capítulo se
destacan las diferentes interpretaciones para reducir al mínimo las posibles
confusiones.


![image](https://user-images.githubusercontent.com/91554777/170126004-d47901e3-6fdc-41ad-9961-d019b16336a5.png)

![image](https://user-images.githubusercontent.com/91554777/170126201-4a1c38da-94d7-4d0c-a28a-f5aa14b9a32f.png)

Tomando el ejemplo en el que estamos trabajando vamos a ingresar los datos a la base, tanto las fechas como el texto lo ingresamos con comillas simples, ademas de DATE para las fechas si queremos solo el año lo declaramos como YEAR.

     CREATE DATABASE biblioteca;
      USE biblioteca;
     CREATE TABLE autores (
     id_autor VARCHAR(100) PRIMARY KEY,
     nombre_autor VARCHAR(100) NOT NULL
     );
     --Insertamos los datos
     INSERT INTO autores VALUES ('aut1','Jan Márquez');
     INSERT INTO autores VALUES ('aut2','Miguel Pérez');
     INSERT INTO autores VALUES ('aut3','Angel Santos');
     INSERT INTO autores VALUES ('aut4','Pedro Sánchez');
     INSERT INTO autores VALUES ('aut5','Daniel Nieves');
     INSERT INTO autores VALUES ('aut6','Adrian Luevano');
     INSERT INTO autores VALUES ('aut7','Ivan Juárez');
     INSERT INTO autores VALUES ('aut8','Wendy Beltran');
     INSERT INTO autores VALUES ('aut9','María Urbina');

     CREATE TABLE libros (
     isbn INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
     editorial VARCHAR(100) NOT NULL,
     año_escritura YEAR, 
     titulo VARCHAR(100) NOT NULL
     );
     INSERT INTO libros VALUES (01,'Editorial Planeta','1998','Pan y vino');
     INSERT INTO libros VALUES (02,'Editorial Editores Mexicanos','1998','Renacer');
     INSERT INTO libros VALUES (03,'Editorial Planeta','1980','Historia del mundo');
     INSERT INTO libros VALUES (04,'Editorial Editanet','1990','Regreso a la Ciudad');
     INSERT INTO libros VALUES (05,'Editorial Editanet','2005','Matemática para niños');
     INSERT INTO libros VALUES (06,'Editorial Editanet','2009','Caso de nuevo');
     INSERT INTO libros VALUES (07,'Editorial Planeta','1974','Manejando las emociones');
     INSERT INTO libros VALUES (08,'Editorial Edimex','1996','Como hacer BD');
     INSERT INTO libros VALUES (09,'Editorial Planeta','1985','Descifrando el futuro');
     INSERT INTO libros VALUES (10,'Editorial Edimex','2010','Angel');

     CREATE TABLE personas (
     dni VARCHAR(10) PRIMARY KEY,
     nombre VARCHAR(50) NOT NULL,
     apellidos VARCHAR(50),
     direccion VARCHAR(100),
     telefono BIGINT UNSIGNED
     );
     INSERT INTO personas VALUES (74659,'Juan Pedro','Martínez Pérez','Av del trabajo #15 colonia petrolera',5567465353);
     INSERT INTO personas VALUES (76589,'Daniel',NULL,NULL,56789835);
     INSERT INTO personas VALUES (878945,'Angélica','Juárez','Priv del desierto #34',554598093);
     INSERT INTO personas VALUES (90867,'Adrián','López Pérez','Aquiles Serdán #34',5567873423);
     INSERT INTO personas VALUES (65478,'Monserrat','Martínez Annaya','Potrero #34 colonia Américas',56784534);
     INSERT INTO personas VALUES (34678,'Ángeles','Sánchez Leal','Av del Rosario #45 colonia Rosario',5576897876);
     INSERT INTO personas VALUES (56749,'Juana','Domíngez Campos','Andador peten #45 colonia Roma',5678563465);
     INSERT INTO personas VALUES (28490,'Andrea','Manrriquez Angulo','Av San pedro #90 colina San Pedro',5598478349);
     INSERT INTO personas VALUES (47893,'Paulo','Dávila Arcos','Patriotismo #12 colonia Puerto Áereo',5545768934);
     INSERT INTO personas VALUES (19840,'Armando','Martínez Hernández','Desccartes #2 colonia Centro',5545123421);

     CREATE TABLE prestamos (
     id_prestamo INT UNSIGNED PRIMARY KEY,
     fecha_real DATE NOT NULL,
     fecha_prestamo DATE NOT NULL,
     dni1 VARCHAR(10),
     FOREIGN KEY (dni1) REFERENCES personas(dni)
     );
     INSERT INTO prestamos VALUES (19,'2022-05-01','2022-03-01',74659);
     INSERT INTO prestamos VALUES (31,'2022-03-12','2022-02-14',74659);
     INSERT INTO prestamos VALUES (45,'2022-05-10','2021-04-13',47893);
     INSERT INTO prestamos VALUES (34,'2022-05-01','2022-05-09',28490);
     INSERT INTO prestamos VALUES (23,'2022-04-15','2022-04-24',19840);

     CREATE TABLE volumenes (
     id_volumen INT UNSIGNED PRIMARY KEY,
     deteriodo VARCHAR(2) NOT NULL,
     id_prestamo1 INT UNSIGNED NOT NULL,
     isbn2  INT UNSIGNED NOT NULL,
     FOREIGN KEY (isbn2) REFERENCES libros(isbn),
     FOREIGN KEY (id_prestamo1) REFERENCES prestamos(id_prestamo)
     );
     INSERT INTO volumenes VALUES (09989,'no',19,01);
     INSERT INTO volumenes VALUES (09990,'si',31,06);
     INSERT INTO volumenes VALUES (09991,'no',45,03);
     INSERT INTO volumenes VALUES (09992,'si',23,04);
     INSERT INTO volumenes VALUES (09993,'no',34,05);

     CREATE TABLE auto_lib (
     id_autor1  VARCHAR(100) NOT NULL,
     isbn1 INT UNSIGNED NOT NULL,
     FOREIGN KEY (id_autor1) REFERENCES autores(id_autor),
     FOREIGN KEY (isbn1) REFERENCES libros(isbn)
     );
     INSERT INTO auto_lib VALUES ('aut2',05);
     INSERT INTO auto_lib VALUES ('aut5',03);
     INSERT INTO auto_lib VALUES ('aut3',01);
     INSERT INTO auto_lib VALUES ('aut1',02);
     INSERT INTO auto_lib VALUES ('aut4',03);


* UNIQUE

Nos permite establecer este atributo a los campos que requerimos tengan datos que no se puedan repetir.

* DELETE

Borra una serie de filas de la tabla. Podemos usar una claúsula WHERE para limitar las filas a borrar, a las que cumplan una condición. La sintaxis sería:

DELETE FROM nombre_tabla WHERE condicion


DELETE FROM libros WHERE id = 2;

O borrar todos los datos de la tabla

DELETE FROM libros;

* TRUNCATE

A diferencia de DELETE, TRUNCATE elimina todas las filas de la tabla sin borrar la tabla. También resetea los contadores de auto incremento a 0. No borra la tabla como tal, la llamada estructura, por lo que luego puede comenzar a hacer inserciones. La sintaxis es:

TRUNCATE TABLE nombre_tabla;

TRUNCATE TABLE libros;

Diferencia entre truncate y delete

![image](https://user-images.githubusercontent.com/91554777/170414244-779243c3-c574-4b58-ad38-befb2e04a334.png)


* DROP

Finalmente llegamos a DROP. A diferencia de la anterior, DROP no sólo elimina los datos, sino que también eliminar la estructura de la tabla.

DROP TABLE nombre_tabla;

DROP TABLE libros;

* DROP DATABASE

Es idéntica a la anterior pero en lugar de borrar una tabla, borra una base de datos al completo. Podemos incluir en la sentencia IF EXISTS de forma que evitemos el error en caso de que no exista la base de datos (muy útil a la hora de hacer copias de seguridad de las bases de datos).

DROP DATABASE [IF EXISTS] nombre_base_datos;

DROP DATABASE biblioteca;

* AUTO INCREMENT  
permite generar un número único cuando insertamos un nuevo registro en la tabla.

Se utiliza para tener una clave primaria de una tabla mediante la generación automática de un número secuencial único en la tabla.

Una clave principal debe ser única ya que identifica de manera única una fila en una base de datos. Pero, ¿cómo podemos asegurarnos de que la clave principal siempre sea única? Una de las soluciones posibles sería utilizar una fórmula para generar la clave principal, que verifica la existencia de la clave en la tabla, antes de agregar datos. Esto puede funcionar bien, pero como puede ver, el enfoque es complejo y no infalible. Para evitar dicha complejidad y garantizar que la clave principal sea siempre única, podemos usar la función Incremento automático de MySQL para generar claves primarias. El incremento automático se usa con el tipo de datos INT. 


![image](https://user-images.githubusercontent.com/91554777/170577536-5b2b2bcd-c0e6-49c3-8ad0-5733db33ae34.png)

![image](https://user-images.githubusercontent.com/91554777/170833598-5a1c0452-d1ab-4727-83c6-a5cdd96b6390.png)

![image](https://user-images.githubusercontent.com/91554777/170833646-3650b39b-b975-4531-82fb-8ebe7cfdf08a.png)

![image](https://user-images.githubusercontent.com/91554777/170833681-e9fb309a-a4d6-49a3-9630-510a2cd1d258.png)


     SELECT * FROM Tabla mostrará todo contenido de la tabla, podemos ser más específicos dandolo solo los campos que se requieren ver.

     SELECT titulo, año_escritura FROM libros; MOstrará toda la tabla libros

     SELECT dni,nombre,telefono 
     FROM personas; Mostrará del dni y el nombre y el teléfono de la tabla personas


     SELECT dni,nombre,id_prestamo
     FROM prestamos INNER JOIN personas on prestamos.dni1=personas.dni; Mostrará el dni, el nombre de la persona y que código de prestamo tiene


     SELECT id_autor,nombre_autor,titulo
     FROM autores INNER JOIN auto_lib on autores.id_autor=auto_lib.id_autor1
     INNER JOIN libros on libros.isbn=auto_lib.isbn1;   Mostrará el id de autor, el nombre del autor y el título del libro que haya escrito.

     SELECT nombre, titulo
     FROM personas INNER JOIN prestamos on prestamos.dni1=personas.dni
     INNER JOIN volumenes on volumenes.id_prestamo1=prestamos.id_prestamo
     INNER JOIN libros on libros.isbn=volumenes.isbn2;   Mostrará el nombre de la persona y el titulo del libro que tiene en prestamo.

     SELECT nombre, titulo,nombre_autor
     FROM personas INNER JOIN prestamos on prestamos.dni1=personas.dni
     INNER JOIN volumenes on volumenes.id_prestamo1=prestamos.id_prestamo
     INNER JOIN libros on libros.isbn=volumenes.isbn2
     INNER JOIN auto_lib on auto_lib.isbn1=libros.isbn
     INNER JOIN autores on id_autor=auto_lib.id_autor1;  Mostrarpa el nombre de la persona, el titulo del libro y el nombre del escritor del libro que tiene en prestamo


     WHERE nombre='Juan Pedro'; Agregando el where le hacemos más específica la muestra, en este caso pido el nombre de la persona que tenga prestamos y que se llame Juan Pedro, usaremos los operadores relacionales para hacer estas especificaciones, estos filtros no necesariamnete enstán en la manifestación de impresión.


     SELECT titulo,año_escritura
     FROM libros
     WHERE año_escritura > '2000';  Mostraría los titulos de los libros que hayan sido escritos después del año 2000.


### UPDATE
Para oder modificar algún campo de la tabla utilizaremos update, debemos considerar que cualquier cambio que hagamos podrá modificar la estructura de la tabla y de la base en general, además que estas actualizaciones o borrado se realizara desde aplicaciones o páginas.

![image](https://user-images.githubusercontent.com/91554777/171032002-c86c2e42-1adf-4f5a-889d-c9c362185262.png)

Con esta opción vamos a actualizar todo el campo, pero podemos ser más específicos con 

![image](https://user-images.githubusercontent.com/91554777/171032088-38a63078-6145-4f75-8685-39d479061062.png)

EJEMPLO

Vamos arealizar una BD de una tienda, aqui vamos a notar como la tabla intermedia que se generará tendrá más atributos que los de claves foraneas porque así lo requiere la relacón.

![image](https://user-images.githubusercontent.com/91554777/171032247-3b144cc0-ceb8-448c-8042-134b33b0efa3.png)

Realizando nuestro diagrama entidad relacion determinaos que la tabla intermedia tendrá sus propios atributos, los cuales serán generados por la interacción con la relación que se de.

![image](https://user-images.githubusercontent.com/91554777/171032439-67bb59c3-862e-49ee-8ae9-96a10b5121fc.png)

![image](https://user-images.githubusercontent.com/91554777/171032474-c780ecf0-29b7-49cf-85d7-be4fc49ef467.png)

![image](https://user-images.githubusercontent.com/91554777/171032524-7640c9a5-dc68-40ea-a81f-64560c8d17bf.png)




https://www.db-fiddle.com/f/x3nyzsY8XxJjRUxadJeM1i/11

Aqui quiza no nos quede muy claro aún la utilidad de generar esa tabla intermedia con sus atributos pero con lanormalización deberá quedar claro.

Si hacemos nuestra consulta de mostrar la tabla clientes veremos los datos de la misma

![image](https://user-images.githubusercontent.com/91554777/171032939-dea79695-4e85-477e-ab5f-a8c876351654.png)

![image](https://user-images.githubusercontent.com/91554777/171032980-80f5f39a-c29c-4305-a56f-e5b490d46d05.png)

Vamos a imaginar deseo modificar el nombre de un cliente, esta incorrecto

![image](https://user-images.githubusercontent.com/91554777/171033268-4287d045-41af-4e8a-a61f-08fede5093b3.png)

Si corremos esto modificará todo el campo, es decir, todos los clientes pasarán a tomar es nombre

![image](https://user-images.githubusercontent.com/91554777/171033486-3b2bdb51-41de-4f7c-8351-4f782bd5fdfc.png)

Para ello usamos WHERE 

![image](https://user-images.githubusercontent.com/91554777/171033661-eafa63d7-ffae-4e76-83dc-11e989bb2e7b.png)

De esa manera se modificará solo el registro que cumpla la condición

![image](https://user-images.githubusercontent.com/91554777/171033720-a106e849-d627-4278-91b3-3676c6111d7d.png)


### FUNCIONES SQL
El lenguaje SQL tiene funciones incorporadas para hacer cálculos sobre los
datos. Las funciones se pueden dividir en dos grupos (existen muchas más,
que dependen del sistema de bases de datos que se utilice):

Funciones agregadas SQL, devuelve un sólo valor, calculado con los valores
de una columna.

● AVG() - La media de los valores

● COUNT() - El número de filas

● MAX() - El valor más grande

● MIN() - El valor más pequeño

● SUM() - La suma de los valores

● GROUP BY - Es una sentencia que va muy ligada a las funciones
agregadas

Funciones escalares SQL, devuelven un sólo valor basándose en el
valor de entrada.

● UCASE() - Convierte un campo a mayúsculas

● LCASE() - Convierte un campo a minúsculas

● MID() - Extrae caracteres de un campo de texto

● LEN() - Devuelve la longitud de un campo de texto

● NOW() - Devuelve la hora y fecha actuales del sistema

● FORMAT() - Da formato a un formato para mostrarlo

Esto nos mostrara la media de los precios

![image](https://user-images.githubusercontent.com/91554777/171034377-846a6f67-06f1-40e3-ad7f-73bf6a4d95ec.png)

![image](https://user-images.githubusercontent.com/91554777/171034406-c57605ed-8033-40bb-8e27-bcfafbdeb535.png)

Esto devolverá el número de filas con determinado criterio

![image](https://user-images.githubusercontent.com/91554777/171034606-58032346-e329-47c2-a0ec-a2c032a30e94.png)

![image](https://user-images.githubusercontent.com/91554777/171034628-73723f5c-9d2a-4653-8317-3a0df988f64d.png)

Esto nos devolverá el precio mas alto

![image](https://user-images.githubusercontent.com/91554777/171034735-61681703-21a1-4167-9569-541854b6ab7f.png)

![image](https://user-images.githubusercontent.com/91554777/171034768-a4f1113d-15fc-4882-b481-aec5a30dcaae.png)

Esto nos devolverá el precio bajo

![image](https://user-images.githubusercontent.com/91554777/171034859-ac506546-263f-46c3-8d9e-4e2dec6c1996.png)

![image](https://user-images.githubusercontent.com/91554777/171034911-fa7a0cfe-a2f7-4f37-8e38-aa2aaf7058e8.png)

En el caso de ejemplo que tenemos las tablas se realacion y esa realción generá la tabla intermedia, supongamos vamos a generar una compra donde X cliente va a comprar X productos

![image](https://user-images.githubusercontent.com/91554777/171035390-9d2f1efd-3d13-4919-99e4-34c6238abd96.png)

![image](https://user-images.githubusercontent.com/91554777/171035459-a48d5e51-bdba-464d-b102-06456c0ff299.png)

![image](https://user-images.githubusercontent.com/91554777/171035481-93f6e503-6893-47aa-85f2-a9dd1824597e.png)

Vemos que el campo subtotal esta como nulo, aqui tendremos que hacer un INER JOIN entre las tablas para obtener este dato

![image](https://user-images.githubusercontent.com/91554777/171035793-a3fa4e5c-f6eb-4fd0-b13a-0104defba060.png)

Ahí le indicamos cual sera el valor de subtotal pero nos marcaría error porque el precio no es campo de la tabla nota

![image](https://user-images.githubusercontent.com/91554777/171065111-161159b7-d0bc-47fd-9b3b-5d8656ead506.png)

Haciendo más específica la impresión

![image](https://user-images.githubusercontent.com/91554777/171065174-6681e31f-1736-4796-b898-7c24425eebf8.png)

### DELETE

![image](https://user-images.githubusercontent.com/91554777/171065348-2845b97b-bb0b-4b3d-b481-4db09dbafcc6.png)


![image](https://user-images.githubusercontent.com/91554777/171065884-198417c4-2577-401d-b2ea-25196e850cf2.png)

Las tablas siguen estando pero los datos se han eliminado

![image](https://user-images.githubusercontent.com/91554777/171066078-4d022556-de2b-4c77-b241-259c3bca54d3.png)

![image](https://user-images.githubusercontent.com/91554777/171066085-9f27874e-4078-4848-b040-a7e6930f4048.png)

Usando DROP si eliminamos la estructura de la tabla, totalmente

![image](https://user-images.githubusercontent.com/91554777/171066375-d932576b-dfac-458c-9c7a-3107a4d042bd.png)

![image](https://user-images.githubusercontent.com/91554777/171066380-1874f339-5a95-4339-a899-bbc8526e7c18.png)

Cuando la tabla a eliminar tiene relaciones con otras no nos dejará eiminar la tabla

Para eliminar toda la BD

![image](https://user-images.githubusercontent.com/91554777/171066783-56ce0248-83df-4213-ac7f-6033bd1fd38a.png)

TRUNCATE, la diferencia con DELETE, entre otras, es que es más rápido ya que hace la eliminación total y DELETE la hace linea por linea

De igual manera no se podrán eliminar si tienen alguna relación con otra tabla por claves foraneas.


La cláusula GROUP BY es un comando SQL que se usa para agrupar filas que tienen los mismos valores .

La cláusula GROUP BY se utiliza en la instrucción SELECT. Opcionalmente se usa junto con funciones agregadas para producir informes resumidos de la base de datos.


Usando el ejemplo anterior en el campo marca de la tabla producto vemos hay varias marcas que se repiten

![image](https://user-images.githubusercontent.com/91554777/171288384-72b624e4-ec08-4f90-ba4a-57832b70659f.png)

Para mostrar por marca los precion máximos

![image](https://user-images.githubusercontent.com/91554777/171289500-9b30396d-230d-40b8-8c46-7284f06dc8a2.png)

Para contar los productos que tiene cada marca

![image](https://user-images.githubusercontent.com/91554777/171289592-b7ac9350-c5b8-405e-ba13-c160370282aa.png)

![image](https://user-images.githubusercontent.com/91554777/171289620-58f34a45-b1df-4d55-8335-2ebcb7814c71.png)

ORDER BY nos permite ordenar los datos en forma ascendente y descendente

si ordenamos la tabla clientes 

![image](https://user-images.githubusercontent.com/91554777/171290972-a023e900-71e8-44e5-b792-232c8bfa79ee.png)

![image](https://user-images.githubusercontent.com/91554777/171291006-f9c1d75f-0f71-4e55-afee-809d7d2be69d.png)

La lista de los precios de productos en forma descendiente

![image](https://user-images.githubusercontent.com/91554777/171291222-c02644d2-b335-40fc-a7f2-95417cca4eca.png)

![image](https://user-images.githubusercontent.com/91554777/171291265-e10afb4c-018d-4513-8cdb-cd68222c0a56.png)


## ALMACENAMIENTO

### Esquemas de almacenes de datos
Data warehouse es un sistema que agrega y combina información de
diferentes fuentes en un almacén de datos único y centralizado;
consistente para respaldar el análisis empresarial, la minería de datos,
inteligencia artificial y Machine Learning. Data warehouse permite a una
organización o empresa ejecutar análisis potentes en grandes
volúmenes petabytes y petabytes de datos históricos de formas que
una base de datos estándar simplemente no puede.

* Esquema estrella: En el esquema de estrella, el centro de la estrella
puede tener una tabla de hechos y varias tablas de dimensiones
asociadas. Se conoce como esquema estelar ya que su estructura se
asemeja a una estrella. El esquema en estrella es el tipo más simple de
esquema de Data Warehouse. También se conoce como Star Join
Schema y está optimizado para consultar grandes conjuntos de datos.

![image](https://user-images.githubusercontent.com/91554777/171292101-9b649a05-7e3f-46e4-8f5a-0ceee3c67f88.png)

Características del esquema estelar:

● Cada dimensión en un esquema de estrella se representa con la
única tabla de una dimensión.

● La tabla de dimensiones debe contener el conjunto de atributos.

● La tabla de dimensiones se une a la tabla de hechos utilizando
una clave foránea.

● Las tablas de dimensiones no están unidas entre sí.

● La tabla de hechos contendría clave y medida.

El esquema estrella es fácil de entender y proporciona un uso óptimo
del disco. Las tablas de dimensiones no están normalizadas.

* Esquema copo de nieve: Un esquema de copo de nieve es una
extensión de un esquema de estrella y agrega dimensiones adicionales.

Se llama como de nieve porque su diagrama se asemeja a un copo de
nieve.

Las tablas de dimensiones están normalizadas, lo que divide los datos
en tablas adicionales. En el siguiente ejemplo, País se normaliza aún
más en una tabla individual.

![image](https://user-images.githubusercontent.com/91554777/171292229-221146de-4444-4e46-b5ba-dce88ad4df4b.png)

Características del esquema de copo de nieve:

● El principal beneficio del esquema de copo de nieve es que utiliza
un espacio en disco más pequeño.

● Debido a múltiples tablas, el rendimiento de la consulta se reduce.

● El principal desafío que enfrentará al usar el esquema de copo de
nieve es que necesita realizar más esfuerzos de mantenimiento
debido a que hay más tablas de búsquedas.

* Esquema Galaxy: Un esquema Galaxy contiene dos tablas de hechos
que comparten tablas de dimensiones. También se llama Fact
Constellation Schema. El esquema se ve como una colección de
estrellas, de ahí el nombre Galaxy Schema.

![image](https://user-images.githubusercontent.com/91554777/171292313-d156dc39-0011-4af5-bdf1-e4a5196b73e4.png)

### Diseño de almacenes de bases de datos práctica
Dentro de la metodología de diseño de un almacén de datos se
encuentran tres etapas diferenciadas que deben ejecutarse en orden
secuencial para la obtención del modelo multidimensional deseado.
Diseño conceptual: Tras el análisis y la recogida de requisitos, se debe
hacer un diseño conceptual multidimensional sobre los datos que
recibimos como input. En un esquema multidimensional se representa
una actividad que es objeto de análisis (hecho) y las dimensiones que
caracterizan la actividad (dimensiones). La información relevante sobre
el hecho se representa por un conjunto de indicadores (medidas o
atributos de hecho).La información descriptiva de cada dimensión se
representa por un conjunto de atributos (atributos de dimensión). Tal y
como se ha comentado anteriormente, el esquema utilizado en las
construcciones de almacenes de datos es el ROLAP y se puede
encontrar varios tipos de representaciones del esquema
multidimensional. Comenzamos presentando el esquema en estrella, en
este esquema, como se puede ver en la figura, la actividad objeto de
estudio se representa en el centro y las dimensiones en las puntas de la
estrella.

Diseño lógico: Una vez definido el modelo multidimensional con el
esquema que se haya seleccionado, se transformará el diagrama de
clases UML a un diagrama relacional sobre el que trabajaremos y
hemos comentado anteriormente, ROLAP. Las dimensiones pasarán a
ser tablas de una base de datos relacional donde se definirá un
identificador único por cada casuística que se produzca en la dimensión.
Este identificador será utilizado más adelante por la tabla de hechos.
Diseño, implementación y explotación de un almacén de datos. El
hecho, al igual que las dimensiones, será una tabla de una base de
datos relacional la cual contendrá los identificadores de cada casuística
producida en las dimensiones y que estén relacionadas entre ellas. Se
definirán claves ajenas a las dimensiones por dichos identificadores.
También, se definirá una clave primaria compuesta por los
identificadores.

Diseño físico: La fase de diseño físico trata de buscar una optimización
de los tiempos de consulta sobre las tablas de hechos y dimensiones.
Tal y como se ha comentado anteriormente, es muy importante que el
usuario obtenga una respuesta rápida a pesar de tener que consultar
una cantidad cuantiosa de datos, del orden de cientos de millones de
registros. En la tabla de hechos se van a realizar acciones de creación
de índices sobre los identificadores de las dimensiones. El orden de las
columnas al crear el índice es muy importante. Además, se valorará la
posibilidad de particionar la tabla a partir de las propias claves, creando
un índice local para cada partición.


Diferencias INNER JOIN Y LEFT JOIN

Con INNER JOIN relacionamos los registros que son comunes, con LEFT JOIN además de los comunes también relaciona los no comunes

EJEMPLO

![image](https://user-images.githubusercontent.com/91554777/171312606-3844e278-5ea7-449d-9c39-72ecb42f7ffd.png)

![image](https://user-images.githubusercontent.com/91554777/171312643-e06dc25c-b062-47f6-b963-0f184fcca580.png)


### triggers
Un trigger o disparador es un script que se usa en lenguaje de
programación SQL, en especial en bases de datos como MySQL o
PostgreSQL. Consiste en una serie de reglas predefinidas que se asocian a
una tabla. Estas reglas se aplican a la base de datos cuando se realizan
determinadas operaciones en la tabla, por ejemplo, al añadir, actualizar o
eliminar registros. Dicho de otra manera, el trigger desencadena
determinadas acciones de forma automática en las tablas de la base de
datos cuando se insertan, modifican y se añaden nuevos datos. Estos
disparadores se llevan usando en MySQL desde la versión 5.0.2., mientras
que PostgreSQL ya los incluyó en el año 1997.

¿Para qué sirve?

La principal función de los trigger es contribuir a mejorar la gestión de la
base de datos. Gracias a ellos muchas operaciones se pueden realizar de
forma automática, sin necesidad de intervención humana, lo que permite
ahorrar mucho tiempo. Otra de sus funciones es aumentar la seguridad e
integridad de la información. Esto lo consiguen gracias a la programación
de restricciones o requerimientos de verificación que permiten minimizar los
errores y sincronizar la información.

¿Cuándo se puede usar un Trigger?

Los trigger se puede ejecutar cuando el usuario realizar alguna acción
relacionada con añadir, actualizar o eliminar información de una tabla. Es
decir, al usar los comandos INSERT, UPDATE o DELETE. Por tanto, para
poder usar un trigger es necesario que el usuario posea permisos INSERT y
DELETE e dicha base de datos.

Los triggers tienen dos escenarios principales de uso:

El primero es cuando no podemos intervenir en el código fuente de la aplicación que trabaja sobre la base de datos sobre la que queremos actuar o reaccionar a sus eventos.

El segundo es cuando a pesar de disponer del código, éste pertenece a un software desarrollado por terceros y existe una probabilidad relativamente alta de aplicar actualizaciones o instalar pluggins, y hemos decidido modificar el código fuente lo menos posible para facilitar este tipo de tareas.

Un ejemplo muy habitual son integraciones de software en las que al menos uno de los programas que intervienen es de código cerrado. En este tipo de situaciones los triggers nos permiten capturar los eventos que modifican la base de datos y actuar en consecuencia, evitando crear tareas programadas y e incluso tablas de integración.

Cuándo no utilizar trigger
Cuando tenemos acceso al código fuente de la aplicación que trabaja sobre la base de datos que nos interesa y no tenemos que mantener ningún tipo de compatibilidad con cambios como nuevas versiones, no existe razón alguna para utilizar triggers.


BEFORE y AFTER

Y como complemento al tipo de sentencia, podemos decidir si intervenir antes o después de que ésta realice los cambios. Así un trigger AFTER INSERT nos permitirá actuar una vez que el nuevo registro este insertado, y un trigger BEFORE DELETE lo hará antes de eliminar un registro.

La combinación del tipo de sentencia con BEFORE o AFTER nos ofrecen mucha versatilidad a la hora de diseñar nuestros triggers.

EJEMPLO_

Creamos una BD con una sola tabla y se requiere generar un log en algunas actualizaciones o al insertar algunos datos a la base.

![image](https://user-images.githubusercontent.com/91554777/171305024-8a44c4c5-08e5-4e74-b385-9de38247e885.png)

Ahora vamos a crear el trigger para que se genere una tabla donde se almacene el registro de actualizacione y otra de inserciones de datos.

![image](https://user-images.githubusercontent.com/91554777/171309761-b21c3d51-3fa9-45fd-a7fc-21b904b98246.png)

NOTA: db-fiddle tiene problemas para ejecutar los triggers, así que solo conoceremos su sintaxis.

En la sintaxis anterior nos ingresaría a la tabla acciones un campo con la leyenda 'se creo un registro', cada que se ingresara un dato a la tabla cliente.

Con DISTINCT nos permite distinguir a los repetidos y enumerarlos de a siguiente manera:

![image](https://user-images.githubusercontent.com/91554777/171553631-36081030-169b-4263-b7b2-f396a7de052d.png)

### DIFERENCIAS ENTRE WHERE Y HAVING
WHERE opera sobre registros individuales, mientras que HAVING lo hace sobre un grupo de registros.

La anterior es la diferencia principal entre estas dos cláusulas. Con WHERE podemos establecer una condición usando registros individuales, aquellos que cumplan con esta condición serán seleccionados (eliminados o actualizados); ahora bien, con HAVING podemos establecer una condición sobre un grupo de registros, algo muy importante es que HAVING acostumbra ir acompañado de la cláusula GROUP BY. Esto último es así dado que HAVING opera sobre los grupos que nos “retorna” GROUP BY.

## NORMALIZACION
<img width="877" alt="image" src="https://user-images.githubusercontent.com/91554777/171753546-32fdaccc-b2a4-454b-8cf5-53e3543bfb4a.png">

<img width="381" alt="image" src="https://user-images.githubusercontent.com/91554777/171753651-41b85b33-8177-431d-a276-89c404f61806.png">

<img width="935" alt="image" src="https://user-images.githubusercontent.com/91554777/171761719-91d1ed6c-8efb-47d5-8b9e-18afe0630845.png">

<img width="937" alt="image" src="https://user-images.githubusercontent.com/91554777/171761682-8856b912-2712-4cd7-b08e-ece880fbf485.png">

<img width="795" alt="image" src="https://user-images.githubusercontent.com/91554777/171754033-ecc2e216-4bbe-4de1-9acb-a54b2d205676.png">

<img width="909" alt="image" src="https://user-images.githubusercontent.com/91554777/171761939-3c3267c7-1e9a-451d-b967-3c011bee3616.png">

En este ejemplo podemos ver que materia es dependiente de codigo de materia pero no asi de matrícula, por lo que nuevamente las vamos a separar, las claves primrias o transitivas deben relacionarse via la clave primaria

<img width="849" alt="image" src="https://user-images.githubusercontent.com/91554777/171755375-fc91c000-945e-48ad-943f-b0f57c2076ac.png">

Ahora vemos que entre matrícula y carrera hay una dependencia trasitiva

<img width="867" alt="image" src="https://user-images.githubusercontent.com/91554777/171763112-e44668d6-b93c-4f5e-9b93-3ffc4df886b0.png">

Veamos un ejemplo de esto desde el diseño

<img width="749" alt="image" src="https://user-images.githubusercontent.com/91554777/171762642-5ddfa1f4-8942-4057-9019-524890e1f425.png">

<img width="483" alt="image" src="https://user-images.githubusercontent.com/91554777/171762716-ddd2f8cb-eacc-4946-9669-6f3489c66ea6.png">

Aplicando la normalización desde la obtención de los datos

<img width="754" alt="image" src="https://user-images.githubusercontent.com/91554777/171762837-f3c83fef-7b36-4543-94db-c7e2613d4945.png">

<img width="922" alt="image" src="https://user-images.githubusercontent.com/91554777/171759077-55f0e7fd-52eb-4850-8023-162f125790df.png">


